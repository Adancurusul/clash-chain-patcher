# 技术方案: 动态SOCKS5代理服务

## 概述

本文档详细描述动态SOCKS5代理服务的技术实现方案。该服务作为一个本地SOCKS5服务器,将客户端流量转发到配置的上游SOCKS5代理。

## 架构设计

### 整体架构

```
┌─────────────┐    SOCKS5     ┌──────────────────┐    SOCKS5     ┌─────────────┐
│   Clash     │──────────────>│  本地代理服务     │──────────────>│   上游      │
│  (或任何    │   127.0.0.1   │ - 协议处理        │   远程地址    │  SOCKS5     │
│   应用)     │    :10808     │ - 转发逻辑        │               │  代理池     │
└─────────────┘               │ - 健康检查        │               └─────────────┘
                              │ - 故障切换        │
                              └──────────────────┘
                                       ↕
                              ┌──────────────────┐
                              │   Makepad GUI    │
                              │ - 配置管理        │
                              │ - 状态监控        │
                              │ - 日志显示        │
                              └──────────────────┘
```

### 模块划分

```
src/
├── main.rs              # 入口
├── app.rs               # GUI (扩展: 添加代理服务Tab)
├── patcher.rs           # YAML修改 (保持不变)
└── proxy/               # 新增: 代理服务模块
    ├── mod.rs           # 模块入口
    ├── server.rs        # SOCKS5服务器
    ├── upstream.rs      # 上游代理管理
    ├── relay.rs         # 流量转发逻辑
    ├── health.rs        # 健康检查
    └── monitor.rs       # 监控和统计
```

## 核心组件详细设计

### 1. SOCKS5服务器 (server.rs)

#### 职责
- 监听本地端口
- 处理SOCKS5协议握手
- 管理客户端连接
- 调用上游管理器获取代理

#### 技术选型
**推荐**: `fast-socks5` + 自定义路由

**理由**:
- 成熟的async/await实现
- 支持自定义处理逻辑
- 活跃维护 (2026年仍在更新)
- 支持TCP和UDP

**替代方案**:
- `socks5-impl`: 更底层,灵活性高但需要更多手动实现
- `tokio-socks5`: Tokio官方示例,但功能基础

#### 核心代码结构

```rust
use fast_socks5::server::{Config, Socks5Server};
use tokio::net::TcpListener;

pub struct ProxyServer {
    config: ServerConfig,
    upstream_manager: Arc<UpstreamManager>,
    stats: Arc<Statistics>,
}

pub struct ServerConfig {
    pub listen_addr: SocketAddr,
    pub auth_required: bool,
    pub timeout: Duration,
}

impl ProxyServer {
    pub async fn start(&self) -> Result<()> {
        let listener = TcpListener::bind(self.config.listen_addr).await?;

        loop {
            let (stream, peer_addr) = listener.accept().await?;

            let upstream = self.upstream_manager.clone();
            let stats = self.stats.clone();

            tokio::spawn(async move {
                handle_client(stream, peer_addr, upstream, stats).await
            });
        }
    }
}

async fn handle_client(
    stream: TcpStream,
    peer: SocketAddr,
    upstream: Arc<UpstreamManager>,
    stats: Arc<Statistics>,
) -> Result<()> {
    // 1. SOCKS5握手
    // 2. 获取目标地址
    // 3. 从上游管理器获取可用代理
    // 4. 建立上游连接
    // 5. 双向转发流量
}
```

### 2. 上游代理管理 (upstream.rs)

#### 职责
- 管理上游代理列表
- 选择可用代理
- 跟踪代理状态
- 提供故障切换

#### 数据结构

```rust
pub struct UpstreamManager {
    proxies: Arc<RwLock<Vec<UpstreamProxy>>>,
    selector: Box<dyn ProxySelector>,
    health_checker: Arc<HealthChecker>,
}

pub struct UpstreamProxy {
    pub id: String,
    pub config: Socks5Config,
    pub status: ProxyStatus,
    pub stats: ProxyStats,
}

pub struct Socks5Config {
    pub host: String,
    pub port: u16,
    pub username: Option<String>,
    pub password: Option<String>,
}

#[derive(Debug, Clone)]
pub enum ProxyStatus {
    Healthy,
    Unhealthy { reason: String },
    Checking,
    Unknown,
}

pub struct ProxyStats {
    pub total_connections: AtomicU64,
    pub active_connections: AtomicU32,
    pub total_bytes_sent: AtomicU64,
    pub total_bytes_recv: AtomicU64,
    pub last_check: Option<Instant>,
    pub latency: Option<Duration>,
}
```

#### 选择策略

```rust
pub trait ProxySelector: Send + Sync {
    fn select(&self, proxies: &[UpstreamProxy]) -> Option<&UpstreamProxy>;
}

// 策略1: 轮询
pub struct RoundRobinSelector {
    counter: AtomicUsize,
}

// 策略2: 随机
pub struct RandomSelector;

// 策略3: 优先级 (按健康状态和延迟)
pub struct PrioritySelector;

// 策略4: 最少连接
pub struct LeastConnectionSelector;
```

### 3. 流量转发 (relay.rs)

#### 职责
- 双向TCP流量转发
- 流量统计
- 超时处理
- 错误恢复

#### 实现方案

**方案A**: 使用 `tokio::io::copy_bidirectional`

```rust
use tokio::io::copy_bidirectional;

pub async fn relay_traffic(
    mut client: TcpStream,
    mut upstream: TcpStream,
    stats: Arc<Statistics>,
) -> Result<()> {
    let (client_to_upstream, upstream_to_client) =
        copy_bidirectional(&mut client, &mut upstream).await?;

    stats.add_bytes_sent(client_to_upstream);
    stats.add_bytes_recv(upstream_to_client);

    Ok(())
}
```

**优点**: 简单可靠,Tokio官方实现
**缺点**: 较少的控制,难以实现细粒度监控

**方案B**: 手动实现双向转发 (推荐)

```rust
pub async fn relay_traffic_manual(
    client: TcpStream,
    upstream: TcpStream,
    stats: Arc<Statistics>,
) -> Result<()> {
    let (mut client_read, mut client_write) = client.into_split();
    let (mut upstream_read, mut upstream_write) = upstream.into_split();

    let client_to_upstream = async {
        let mut buf = vec![0u8; 8192];
        loop {
            let n = client_read.read(&mut buf).await?;
            if n == 0 { break; }

            upstream_write.write_all(&buf[..n]).await?;
            stats.add_bytes_sent(n as u64);
        }
        Ok::<_, io::Error>(())
    };

    let upstream_to_client = async {
        let mut buf = vec![0u8; 8192];
        loop {
            let n = upstream_read.read(&mut buf).await?;
            if n == 0 { break; }

            client_write.write_all(&buf[..n]).await?;
            stats.add_bytes_recv(n as u64);
        }
        Ok::<_, io::Error>(())
    };

    tokio::try_join!(client_to_upstream, upstream_to_client)?;
    Ok(())
}
```

**优点**: 完整控制,可添加自定义逻辑
**缺点**: 代码量稍多

#### 性能优化

```rust
// 优化1: 使用更大的缓冲区
const BUFFER_SIZE: usize = 16384; // 16KB

// 优化2: 使用tokio-splice (Linux zero-copy)
#[cfg(target_os = "linux")]
use tokio_splice::zero_copy_bidirectional;

// 优化3: 连接池复用
pub struct ConnectionPool {
    pools: HashMap<SocketAddr, VecDeque<TcpStream>>,
    max_idle: usize,
}
```

### 4. 健康检查 (health.rs)

#### 职责
- 定期检查上游代理可用性
- 更新代理状态
- 触发故障切换

#### 检查策略

```rust
pub struct HealthChecker {
    config: HealthCheckConfig,
    upstream_manager: Weak<UpstreamManager>,
}

pub struct HealthCheckConfig {
    pub interval: Duration,        // 检查间隔 (默认: 30s)
    pub timeout: Duration,          // 检查超时 (默认: 5s)
    pub target_url: String,         // 检查目标 (默认: http://www.gstatic.com/generate_204)
    pub failure_threshold: u32,     // 失败阈值 (默认: 3)
    pub success_threshold: u32,     // 成功阈值 (默认: 2)
}

impl HealthChecker {
    pub async fn start(&self) {
        let mut interval = tokio::time::interval(self.config.interval);

        loop {
            interval.tick().await;
            self.check_all_proxies().await;
        }
    }

    async fn check_proxy(&self, proxy: &UpstreamProxy) -> HealthCheckResult {
        let start = Instant::now();

        // 通过代理连接测试目标
        let result = timeout(
            self.config.timeout,
            connect_via_proxy(proxy, &self.config.target_url)
        ).await;

        let latency = start.elapsed();

        match result {
            Ok(Ok(_)) => HealthCheckResult::Success { latency },
            Ok(Err(e)) => HealthCheckResult::Failed { reason: e.to_string() },
            Err(_) => HealthCheckResult::Timeout,
        }
    }
}

pub enum HealthCheckResult {
    Success { latency: Duration },
    Failed { reason: String },
    Timeout,
}
```

#### 检查方法

**方法1**: TCP连接测试
```rust
async fn check_tcp_connect(proxy: &Socks5Config) -> Result<Duration> {
    let start = Instant::now();
    let stream = TcpStream::connect((proxy.host.as_str(), proxy.port)).await?;
    drop(stream);
    Ok(start.elapsed())
}
```

**方法2**: SOCKS5握手测试 (推荐)
```rust
async fn check_socks5_handshake(proxy: &Socks5Config) -> Result<Duration> {
    let start = Instant::now();

    let stream = TcpStream::connect((proxy.host.as_str(), proxy.port)).await?;
    let mut client = Socks5Stream::connect(
        stream,
        "www.gstatic.com",
        80,
        proxy.username.clone(),
        proxy.password.clone()
    ).await?;

    // 发送HTTP HEAD请求
    client.write_all(b"HEAD /generate_204 HTTP/1.0\r\n\r\n").await?;

    let mut buf = [0u8; 1024];
    client.read(&mut buf).await?;

    Ok(start.elapsed())
}
```

**方法3**: 完整HTTP请求测试
```rust
async fn check_http_request(proxy: &Socks5Config) -> Result<Duration> {
    // 使用reqwest + SOCKS5代理
    let proxy_url = format!("socks5://{}:{}", proxy.host, proxy.port);
    let client = reqwest::Client::builder()
        .proxy(reqwest::Proxy::all(&proxy_url)?)
        .timeout(Duration::from_secs(5))
        .build()?;

    let start = Instant::now();
    let response = client
        .get("http://www.gstatic.com/generate_204")
        .send()
        .await?;

    if response.status() == 204 {
        Ok(start.elapsed())
    } else {
        Err(anyhow!("Unexpected status: {}", response.status()))
    }
}
```

### 5. 监控和统计 (monitor.rs)

#### 职责
- 收集实时统计数据
- 提供查询接口
- 触发GUI更新

#### 数据结构

```rust
pub struct Statistics {
    // 全局统计
    pub total_connections: AtomicU64,
    pub active_connections: AtomicU32,
    pub total_bytes_sent: AtomicU64,
    pub total_bytes_recv: AtomicU64,

    // 连接记录
    connections: Arc<RwLock<VecDeque<ConnectionRecord>>>,
    max_records: usize,
}

pub struct ConnectionRecord {
    pub id: u64,
    pub client_addr: SocketAddr,
    pub target_addr: String,
    pub upstream_id: String,
    pub start_time: Instant,
    pub end_time: Option<Instant>,
    pub bytes_sent: u64,
    pub bytes_recv: u64,
    pub status: ConnectionStatus,
}

pub enum ConnectionStatus {
    Active,
    Completed,
    Failed { reason: String },
}
```

## GUI集成

### Tab结构

```rust
// app.rs 扩展

pub struct App {
    // 现有字段
    pub config_tab: ConfigTab,  // 原有的配置修改Tab

    // 新增字段
    pub proxy_tab: ProxyTab,    // 新增的代理服务Tab
    pub current_tab: TabType,
}

pub enum TabType {
    ConfigModify,  // 配置修改
    ProxyServer,   // 代理服务
}

pub struct ProxyTab {
    pub server: Option<Arc<ProxyServer>>,
    pub server_state: ServerState,
    pub upstream_list: Vec<UpstreamProxyUI>,
    pub selected_upstream: Option<String>,
    pub stats: StatisticsUI,
    pub log_buffer: VecDeque<String>,
}

pub enum ServerState {
    Stopped,
    Starting,
    Running { listen_addr: SocketAddr },
    Stopping,
    Error { message: String },
}
```

### 状态同步

```rust
// 使用tokio::sync::watch 同步状态
pub struct ProxyServerHandle {
    state_tx: watch::Sender<ServerState>,
    stats_rx: watch::Receiver<Statistics>,
    command_tx: mpsc::Sender<ServerCommand>,
}

pub enum ServerCommand {
    Start,
    Stop,
    AddUpstream(Socks5Config),
    RemoveUpstream(String),
    SwitchUpstream(String),
}
```

## 配置持久化

```rust
// 保存到本地配置文件
pub struct ProxyServiceConfig {
    pub listen_addr: String,
    pub upstreams: Vec<Socks5Config>,
    pub active_upstream: Option<String>,
    pub health_check: HealthCheckConfig,
    pub selector_type: SelectorType,
}

pub enum SelectorType {
    RoundRobin,
    Random,
    Priority,
    LeastConnection,
}

// 使用serde序列化到YAML
impl ProxyServiceConfig {
    pub fn load() -> Result<Self> {
        let config_path = Self::config_path()?;
        let content = fs::read_to_string(config_path)?;
        Ok(serde_yaml::from_str(&content)?)
    }

    pub fn save(&self) -> Result<()> {
        let config_path = Self::config_path()?;
        let content = serde_yaml::to_string(self)?;
        fs::write(config_path, content)?;
        Ok(())
    }

    fn config_path() -> Result<PathBuf> {
        let config_dir = dirs::config_dir()
            .ok_or_else(|| anyhow!("Cannot determine config directory"))?;
        Ok(config_dir.join("clash-chain-patcher").join("proxy-service.yaml"))
    }
}
```

## 依赖清单

### 新增依赖

```toml
[dependencies]
# 异步运行时
tokio = { version = "1.43", features = ["full"] }

# SOCKS5协议
fast-socks5 = "0.9"

# 错误处理
anyhow = "1.0"
thiserror = "1.0"

# 日志
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# 配置管理
dirs = "5.0"

# HTTP客户端 (用于健康检查)
reqwest = { version = "0.12", features = ["socks"] }

# 可选: 性能优化
[target.'cfg(target_os = "linux")'.dependencies]
tokio-splice = "0.7"
```

## 实施计划

### 阶段1: 核心功能 (2周)
1. 实现基本SOCKS5服务器
2. 实现单上游代理转发
3. 基础GUI集成 (启动/停止按钮)

### 阶段2: 健康检查 (1周)
1. 实现健康检查逻辑
2. 实现状态更新
3. GUI状态显示

### 阶段3: 多上游管理 (1周)
1. 实现上游列表管理
2. 实现选择策略
3. GUI列表操作

### 阶段4: 监控和优化 (1周)
1. 实现统计收集
2. GUI监控面板
3. 性能优化

### 阶段5: 测试和文档 (1周)
1. 单元测试
2. 集成测试
3. 用户文档

## 风险和缓解

### 风险1: SOCKS5协议兼容性
- **缓解**: 使用成熟的fast-socks5库
- **备选**: 实现自己的协议处理以应对特殊情况

### 风险2: 性能瓶颈
- **缓解**: 使用异步IO,避免阻塞
- **优化**: 引入连接池和zero-copy

### 风险3: 跨平台问题
- **缓解**: 充分测试三个平台
- **回退**: 移除平台特定优化

## 参考资源

- [fast-socks5 GitHub](https://github.com/dizda/fast-socks5)
- [Tokio官方proxy示例](https://github.com/tokio-rs/tokio/blob/master/examples/proxy.rs)
- [Rust SOCKS5开发指南](https://www.pyproxy.com/information/how-to-develop-an-efficient-socks5-proxy-with-rust.html)
- [Tokio I/O模式](https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/)
- [hydra5负载均衡](https://github.com/igrigorik/hydra5)
